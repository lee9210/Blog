title: „ÄêÂç†Â∞èÁãº„ÄëÊ∑±ÂÖ•ÊµÖÂá∫ Netty read
date: 2018-01-06
tags:
categories: Netty
permalink: Netty/zhanxiaolang/read
author: Âç†Â∞èÁãº
from_url: https://www.jianshu.com/p/6b48196b5043
wechat_url: https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247484643&idx=1&sn=88b9c980992ae39a3581d729856ddeb4&chksm=fa497b52cd3ef2441b58531156f95f3aa6bb5ea3f6c677afe87902f21c78c6569810564650ab#rd

-------

ÊëòË¶Å: ÂéüÂàõÂá∫Â§Ñ https://www.jianshu.com/p/6b48196b5043 „ÄåÂç†Â∞èÁãº„ÄçÊ¨¢ËøéËΩ¨ËΩΩÔºå‰øùÁïôÊëòË¶ÅÔºåË∞¢Ë∞¢ÔºÅ


-------

![](http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg)

> üôÇüôÇüôÇÂÖ≥Ê≥®**ÂæÆ‰ø°ÂÖ¨‰ºóÂè∑Ôºö„ÄêËäãÈÅìÊ∫êÁ†Å„Äë**ÊúâÁ¶èÂà©Ôºö
> 1. RocketMQ / MyCAT / Sharding-JDBC **ÊâÄÊúâ**Ê∫êÁ†ÅÂàÜÊûêÊñáÁ´†ÂàóË°®
> 2. RocketMQ / MyCAT / Sharding-JDBC **‰∏≠ÊñáÊ≥®ÈáäÊ∫êÁ†Å GitHub Âú∞ÂùÄ**
> 3. ÊÇ®ÂØπ‰∫éÊ∫êÁ†ÅÁöÑÁñëÈóÆÊØèÊù°ÁïôË®Ä**ÈÉΩ**Â∞ÜÂæóÂà∞**ËÆ§Áúü**ÂõûÂ§ç„ÄÇ**ÁîöËá≥‰∏çÁü•ÈÅìÂ¶Ç‰ΩïËØªÊ∫êÁ†Å‰πüÂèØ‰ª•ËØ∑ÊïôÂô¢**„ÄÇ
> 4. **Êñ∞ÁöÑ**Ê∫êÁ†ÅËß£ÊûêÊñáÁ´†**ÂÆûÊó∂**Êî∂Âà∞ÈÄöÁü•„ÄÇ**ÊØèÂë®Êõ¥Êñ∞‰∏ÄÁØáÂ∑¶Âè≥**„ÄÇ
> 5. **ËÆ§ÁúüÁöÑ**Ê∫êÁ†Å‰∫§ÊµÅÂæÆ‰ø°Áæ§„ÄÇ

-------

bossÁ∫øÁ®ã‰∏ªË¶ÅË¥üË¥£ÁõëÂê¨Âπ∂Â§ÑÁêÜaccept‰∫ã‰ª∂ÔºåÂ∞ÜsocketChannelÊ≥®ÂÜåÂà∞workÁ∫øÁ®ãÁöÑselectorÔºåÁî±workerÁ∫øÁ®ãÊù•ÁõëÂê¨Âπ∂Â§ÑÁêÜread‰∫ã‰ª∂ÔºåÊú¨ËäÇ‰∏ªË¶ÅÂàÜÊûêNettyÂ¶Ç‰ΩïÂ§ÑÁêÜread‰∫ã‰ª∂„ÄÇ

![img](http://upload-images.jianshu.io/upload_images/2184951-3afb05bc34f28479.png)

accept->read

ÂΩìworkÁ∫øÁ®ãÁöÑselectorÊ£ÄÊµãÂà∞OP_READ‰∫ã‰ª∂ÂèëÁîüÊó∂ÔºåËß¶ÂèëreadÊìç‰Ωú„ÄÇ

```Java
//NioEventLoop
if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
    unsafe.read();
    if (!ch.isOpen()) {
        // Connection already closed - no need to handle write.
        return;
    }
}
```

ËØ•readÊñπÊ≥ïÂÆö‰πâÂú®Á±ªNioByteUnsafe‰∏≠„ÄÇ

```Java
//AbstractNioByteChannel.NioByteUnsafe
public final void read() {
    final ChannelConfig config = config();
    if (!config.isAutoRead() && !isReadPending()) {
        // ChannelConfig.setAutoRead(false) was called in the meantime
        removeReadOp();
        return;
    }

    final ChannelPipeline pipeline = pipeline();
    final ByteBufAllocator allocator = config.getAllocator();
    final int maxMessagesPerRead = config.getMaxMessagesPerRead();
    RecvByteBufAllocator.Handle allocHandle = this.allocHandle;
    if (allocHandle == null) {
        this.allocHandle = allocHandle = config.getRecvByteBufAllocator().newHandle();
    }

    ByteBuf byteBuf = null;
    int messages = 0;
    boolean close = false;
    try {
        int totalReadAmount = 0;
        boolean readPendingReset = false;
        do {
            byteBuf = allocHandle.allocate(allocator);
            int writable = byteBuf.writableBytes();
            int localReadAmount = doReadBytes(byteBuf);
            if (localReadAmount <= 0) {
                // not was read release the buffer
                byteBuf.release();
                byteBuf = null;
                close = localReadAmount < 0;
                break;
            }
            if (!readPendingReset) {
                readPendingReset = true;
                setReadPending(false);
            }
            pipeline.fireChannelRead(byteBuf);
            byteBuf = null;

            if (totalReadAmount >= Integer.MAX_VALUE - localReadAmount) {
                // Avoid overflow.
                totalReadAmount = Integer.MAX_VALUE;
                break;
            }

            totalReadAmount += localReadAmount;

            // stop reading
            if (!config.isAutoRead()) {
                break;
            }

            if (localReadAmount < writable) {
                // Read less than what the buffer can hold,
                // which might mean we drained the recv buffer completely.
                break;
            }
        } while (++ messages < maxMessagesPerRead);

        pipeline.fireChannelReadComplete();
        allocHandle.record(totalReadAmount);

        if (close) {
            closeOnRead(pipeline);
            close = false;
        }
    } catch (Throwable t) {
        handleReadException(pipeline, byteBuf, t, close);
    } finally {
        // Check if there is a readPending which was not processed yet.
        // This could be for two reasons:
        // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
        // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
        //
        // See https://github.com/netty/netty/issues/2254
        if (!config.isAutoRead() && !isReadPending()) {
            removeReadOp();
        }
    }
}
```

1„ÄÅallocHandleË¥üË¥£Ëá™ÈÄÇÂ∫îË∞ÉÊï¥ÂΩìÂâçÁºìÂ≠òÂàÜÈÖçÁöÑÂ§ßÂ∞èÔºå‰ª•Èò≤Ê≠¢ÁºìÂ≠òÂàÜÈÖçËøáÂ§öÊàñËøáÂ∞ëÔºåÂÖàÁúãÁúãAdaptiveRecvByteBufAllocatorÂÜÖÈÉ®ÂÆûÁé∞Ôºö

```Java
public class AdaptiveRecvByteBufAllocator implements RecvByteBufAllocator {
    static final int DEFAULT_MINIMUM = 64;
    static final int DEFAULT_INITIAL = 1024;
    static final int DEFAULT_MAXIMUM = 65536;
    private static final int INDEX_INCREMENT = 4;
    private static final int INDEX_DECREMENT = 1;
    private static final int[] SIZE_TABLE;
}
```

**SIZE_TABLE**ÔºöÊåâÁÖß‰ªéÂ∞èÂà∞Â§ßÁöÑÈ°∫Â∫èÈ¢ÑÂÖàÂ≠òÂÇ®ÂèØ‰ª•ÂàÜÈÖçÁöÑÁºìÂ≠òÂ§ßÂ∞è„ÄÇ
‰ªé16ÂºÄÂßãÔºåÊØèÊ¨°Á¥ØÂä†16ÔºåÁõ¥Âà∞496ÔºåÊé•ÁùÄ‰ªé512ÂºÄÂßãÔºåÊØèÊ¨°Â¢ûÂ§ß‰∏ÄÂÄçÔºåÁõ¥Âà∞Ê∫¢Âá∫„ÄÇ
**DEFAULT_MINIMUM**ÔºöÊúÄÂ∞èÁºìÂ≠òÔºà64ÔºâÔºåÂú®SIZE_TABLE‰∏≠ÂØπÂ∫îÁöÑ‰∏ãÊ†á‰∏∫3„ÄÇ
**DEFAULT_MAXIMUM **ÔºöÊúÄÂ§ßÁºìÂ≠òÔºà65536ÔºâÔºåÂú®SIZE_TABLE‰∏≠ÂØπÂ∫îÁöÑ‰∏ãÊ†á‰∏∫38„ÄÇ
**DEFAULT_INITIAL **ÔºöÂàùÂßãÂåñÁºìÂ≠òÂ§ßÂ∞èÔºåÁ¨¨‰∏ÄÊ¨°ÂàÜÈÖçÁºìÂ≠òÊó∂ÔºåÁî±‰∫éÊ≤°Êúâ‰∏ä‰∏ÄÊ¨°ÂÆûÈôÖÊî∂Âà∞ÁöÑÂ≠óËäÇÊï∞ÂÅöÂèÇËÄÉÔºåÈúÄË¶ÅÁªô‰∏Ä‰∏™ÈªòËÆ§ÂàùÂßãÂÄº„ÄÇ
**INDEX_INCREMENT**Ôºö‰∏äÊ¨°È¢Ñ‰º∞ÁºìÂ≠òÂÅèÂ∞èÔºå‰∏ãÊ¨°indexÁöÑÈÄíÂ¢ûÂÄº„ÄÇ
**INDEX_DECREMENT **Ôºö‰∏äÊ¨°È¢Ñ‰º∞ÁºìÂ≠òÂÅèÂ§ßÔºå‰∏ãÊ¨°indexÁöÑÈÄíÂáèÂÄº„ÄÇ

2„ÄÅallocHandle.allocate(allocator) Áî≥ËØ∑‰∏ÄÂùóÊåáÂÆöÂ§ßÂ∞èÁöÑÂÜÖÂ≠ò„ÄÇ

```Java
//AdaptiveRecvByteBufAllocator.HandleImpl
public ByteBuf allocate(ByteBufAllocator alloc) {
    return alloc.ioBuffer(nextReceiveBufferSize);
}
```

ÈÄöËøáByteBufAllocatorÁöÑioBufferÊñπÊ≥ïÁî≥ËØ∑ÁºìÂ≠ò„ÄÇ

```Java
//AbstractByteBufAllocator
public ByteBuf ioBuffer(int initialCapacity) {
    if (PlatformDependent.hasUnsafe()) {
        return directBuffer(initialCapacity);
    }
    return heapBuffer(initialCapacity);
}
```

Ê†πÊçÆÂπ≥Âè∞ÊòØÂê¶ÊîØÊåÅunsafeÔºåÈÄâÊã©‰ΩøÁî®Áõ¥Êé•Áâ©ÁêÜÂÜÖÂ≠òËøòÊòØÂ†Ü‰∏äÂÜÖÂ≠ò„ÄÇ

direct bufferÊñπÊ°àÔºö

```Java
//AbstractByteBufAllocator
public ByteBuf directBuffer(int initialCapacity) {
    return directBuffer(initialCapacity, Integer.MAX_VALUE);
}

public ByteBuf directBuffer(int initialCapacity, int maxCapacity) {
    if (initialCapacity == 0 && maxCapacity == 0) {
        return emptyBuf;
    }
    validate(initialCapacity, maxCapacity);
    return newDirectBuffer(initialCapacity, maxCapacity);
}

//UnpooledByteBufAllocator
protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) {
    ByteBuf buf;
    if (PlatformDependent.hasUnsafe()) {
        buf = new UnpooledUnsafeDirectByteBuf(this, initialCapacity, maxCapacity);
    } else {
        buf = new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);
    }
    return toLeakAwareBuffer(buf);
}
```

UnpooledUnsafeDirectByteBufÊòØÂ¶Ç‰ΩïÂÆûÁé∞ÁºìÂ≠òÁÆ°ÁêÜÁöÑÔºüÂØπNioÁöÑByteBufferËøõË°å‰∫ÜÂ∞ÅË£ÖÔºåÈÄöËøáByteBufferÁöÑallocateDirectÊñπÊ≥ïÂÆûÁé∞ÁºìÂ≠òÁöÑÁî≥ËØ∑„ÄÇ

```Java
protected UnpooledUnsafeDirectByteBuf(ByteBufAllocator alloc, ByteBuffer initialBuffer, int maxCapacity) {
    //Âà§Êñ≠ÈÄªËæëÂ∑≤ÁªèÂøΩÁï•
   this.alloc = alloc;
   setByteBuffer(allocateDirect(initialCapacity));
}

protected ByteBuffer allocateDirect(int initialCapacity) {
    return ByteBuffer.allocateDirect(initialCapacity);
}

private void setByteBuffer(ByteBuffer buffer) {
    ByteBuffer oldBuffer = this.buffer;
    if (oldBuffer != null) {
        if (doNotFree) {
            doNotFree = false;
        } else {
            freeDirect(oldBuffer);
        }
    }
    this.buffer = buffer;
    memoryAddress = PlatformDependent.directBufferAddress(buffer);
    tmpNioBuf = null;
    capacity = buffer.remaining();
}
```

memoryAddress = PlatformDependent.directBufferAddress(buffer) Ëé∑ÂèñbufferÁöÑaddressÂ≠óÊÆµÂÄºÔºåÊåáÂêëÁºìÂ≠òÂú∞ÂùÄ„ÄÇ
capacity = buffer.remaining() Ëé∑ÂèñÁºìÂ≠òÂÆπÈáè„ÄÇ

ÊñπÊ≥ïtoLeakAwareBuffer(buf)ÂØπÁî≥ËØ∑ÁöÑbufÂèàËøõË°å‰∫Ü‰∏ÄÊ¨°ÂåÖË£ÖÔºö

```Java
protected static ByteBuf toLeakAwareBuffer(ByteBuf buf) {
    ResourceLeak leak;
    switch (ResourceLeakDetector.getLevel()) {
        case SIMPLE:
            leak = AbstractByteBuf.leakDetector.open(buf);
            if (leak != null) {
                buf = new SimpleLeakAwareByteBuf(buf, leak);
            }
            break;
        case ADVANCED:
        case PARANOID:
            leak = AbstractByteBuf.leakDetector.open(buf);
            if (leak != null) {
                buf = new AdvancedLeakAwareByteBuf(buf, leak);
            }
            break;
    }
    return buf;
}
```

Netty‰∏≠‰ΩøÁî®ÂºïÁî®ËÆ°Êï∞Êú∫Âà∂Êù•ÁÆ°ÁêÜËµÑÊ∫êÔºåByteBufÂÆûÁé∞‰∫ÜReferenceCountedÊé•Âè£ÔºåÂΩìÂÆû‰æãÂåñ‰∏Ä‰∏™ByteBufÊó∂ÔºåÂºïÁî®ËÆ°Êï∞‰∏∫1Ôºå ‰ª£Á†Å‰∏≠ÈúÄË¶Å‰øùÊåÅ‰∏Ä‰∏™ËØ•ÂØπË±°ÁöÑÂºïÁî®Êó∂ÈúÄË¶ÅË∞ÉÁî®retainÊñπÊ≥ïÂ∞ÜËÆ°Êï∞Â¢û1ÔºåÂØπË±°‰ΩøÁî®ÂÆåÊó∂Ë∞ÉÁî®releaseÂ∞ÜËÆ°Êï∞Âáè1„ÄÇÂΩìÂºïÁî®ËÆ°Êï∞Âèò‰∏∫0Êó∂ÔºåÂØπË±°Â∞ÜÈáäÊîæÊâÄÊåÅÊúâÁöÑÂ∫ïÂ±ÇËµÑÊ∫êÊàñÂ∞ÜËµÑÊ∫êËøîÂõûËµÑÊ∫êÊ±†„ÄÇ

3„ÄÅÊñπÊ≥ïdoReadBytes(byteBuf) Â∞ÜsocketChannelÊï∞ÊçÆÂÜôÂÖ•ÁºìÂ≠ò„ÄÇ

```Java
//NioSocketChannel
@Override
protected int doReadBytes(ByteBuf byteBuf) throws Exception {
    return byteBuf.writeBytes(javaChannel(), byteBuf.writableBytes());
}

//WrappedByteBuf
@Override
public int writeBytes(ScatteringByteChannel in, int length) throws IOException {
    return buf.writeBytes(in, length);
}

//AbsractByteBuf
@Override
public int writeBytes(ScatteringByteChannel in, int length) throws IOException {
    ensureAccessible();
    ensureWritable(length);
    int writtenBytes = setBytes(writerIndex, in, length);
    if (writtenBytes > 0) {
        writerIndex += writtenBytes;
    }
    return writtenBytes;
}

//UnpooledUnsafeDirectByteBuf
@Override
public int setBytes(int index, ScatteringByteChannel in, int length) throws IOException {
    ensureAccessible();
    ByteBuffer tmpBuf = internalNioBuffer();
    tmpBuf.clear().position(index).limit(index + length);
    try {
        return in.read(tmpBuf);
    } catch (ClosedChannelException ignored) {
        return -1;
    }
}

private ByteBuffer internalNioBuffer() {
    ByteBuffer tmpNioBuf = this.tmpNioBuf;
    if (tmpNioBuf == null) {
        this.tmpNioBuf = tmpNioBuf = buffer.duplicate();
    }
    return tmpNioBuf;
}
```

ÊúÄÁªàÂ∫ïÂ±ÇÈááÁî®ByteBufferÂÆûÁé∞readÊìç‰ΩúÔºåËøôÈáåÊúâ‰∏ÄÂùóÈÄªËæë‰∏çÊ∏ÖÊ•öÔºå‰∏∫‰ªÄ‰πàË¶ÅÁî®tmpNioBufÔºü

int localReadAmount = doReadBytes(byteBuf);
1„ÄÅÂ¶ÇÊûúËøîÂõû0ÔºåÂàôË°®Á§∫Ê≤°ÊúâËØªÂèñÂà∞Êï∞ÊçÆÔºåÂàôÈÄÄÂá∫Âæ™ÁéØ„ÄÇ
2„ÄÅÂ¶ÇÊûúËøîÂõû-1ÔºåË°®Á§∫ÂØπÁ´ØÂ∑≤ÁªèÂÖ≥Èó≠ËøûÊé•ÔºåÂàôÈÄÄÂá∫Âæ™ÁéØ„ÄÇ
3„ÄÅÂê¶ÂàôÔºåË°®Á§∫ËØªÂèñÂà∞‰∫ÜÊï∞ÊçÆÔºåÊï∞ÊçÆËØªÂÖ•ÁºìÂ≠òÂêéÔºåËß¶ÂèëpipelineÁöÑChannelRead‰∫ã‰ª∂ÔºåbyteBuf‰Ωú‰∏∫ÂèÇÊï∞ËøõË°åÂêéÁª≠Â§ÑÁêÜÔºåËøôÊó∂Ëá™ÂÆö‰πâInboundÁ±ªÂûãÁöÑhandlerÂ∞±ÂèØ‰ª•ËøõË°å‰∏öÂä°Â§ÑÁêÜ‰∫Ü„ÄÇ

```Java
static class DiscardServerHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ByteBuf in = (ByteBuf) msg;
        try {
            while (in.isReadable()) { // (1)
                System.out.print((char) in.readByte());
                System.out.flush();
            }
        } finally {
            ReferenceCountUtil.release(msg); // (2)
        }
    }
}
```

ÂÖ∂‰∏≠ÂèÇÊï∞msgÔºåÂ∞±ÊòØÂØπÂ∫îÁöÑbyteBufÔºåÂΩìËØ∑Ê±ÇÁöÑÊï∞ÊçÆÈáèÊØîËæÉÂ§ßÊó∂Ôºå‰ºöÂ§öÊ¨°Ëß¶ÂèëchannelRead‰∫ã‰ª∂ÔºåÈªòËÆ§ÊúÄÂ§öËß¶Âèë16Ê¨°ÔºåÂèØ‰ª•ÈÄöËøámaxMessagesPerReadÂ≠óÊÆµËøõË°åÈÖçÁΩÆ„ÄÇ
Â¶ÇÊûúÂÆ¢Êà∑Á´Ø‰º†ËæìÁöÑÊï∞ÊçÆËøáÂ§ßÔºåÂèØËÉΩ‰ºöÂàÜÊàêÂ•ΩÂá†Ê¨°‰º†ËæìÔºåÂõ†‰∏∫TCP‰∏ÄÊ¨°‰º†ËæìÂÜÖÂÆπÂ§ßÂ∞èÊúâ‰∏äÈôêÔºåÊâÄ‰ª•Âêå‰∏Ä‰∏™selectKey‰ºöËß¶ÂèëÂ§öÊ¨°read‰∫ã‰ª∂ÔºåÂâ©‰ΩôÁöÑÊï∞ÊçÆ‰ºöÂú®‰∏ã‰∏ÄËΩÆselectÊìç‰ΩúÁªßÁª≠ËØªÂèñ„ÄÇ

Âú®ÂÆûÈôÖÂ∫îÁî®‰∏≠ÔºåÂ∫îËØ•ÊääÊâÄÊúâËØ∑Ê±ÇÊï∞ÊçÆÈÉΩÁºìÂ≠òËµ∑Êù•ÂÜçËøõË°å‰∏öÂä°Â§ÑÁêÜ„ÄÇ
ÊâÄÊúâÊï∞ÊçÆÈÉΩÂ§ÑÁêÜÂÆåÔºåËß¶ÂèëpipelineÁöÑChannelReadComplete‰∫ã‰ª∂ÔºåÂπ∂‰∏îallocHandleËÆ∞ÂΩïËøôÊ¨°readÁöÑÂ≠óËäÇÊï∞ÔºåËøõË°å‰∏ãÊ¨°Â§ÑÁêÜÊó∂ÁºìÂ≠òÂ§ßÂ∞èÁöÑË∞ÉÊï¥„ÄÇ

Âà∞Ê≠§‰∏∫Ê≠¢ÔºåÊï¥‰∏™NioSocketChannelÁöÑread‰∫ã‰ª∂Â∑≤ÁªèÂ§ÑÁêÜÂÆåÊàê„ÄÇ

# 666. ÂΩ©Ëõã

Â¶ÇÊûú‰Ω†ÂØπ Netty Âπ∂ÂèëÊÑüÂÖ¥Ë∂£ÔºåÊ¨¢ËøéÂä†ÂÖ•ÊàëÁöÑÁü•ËØÜÊòüÁêÉ‰∏ÄËµ∑‰∫§ÊµÅ„ÄÇ

![Áü•ËØÜÊòüÁêÉ](http://www.iocoder.cn/images/Architecture/2017_12_29/01.png)